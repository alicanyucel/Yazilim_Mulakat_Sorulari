â€“ Transient: Nesneye yapÄ±lan her Ã§aÄŸrÄ±da yeni bir nesne oluÅŸturulur. Stateless nesneye ihtiyaÃ§ duyulan durumlarda kullanÄ±lÄ±r. AddTransient() metodu aracÄ±lÄ±ÄŸÄ±yla Transient tipinde baÄŸÄ±mlÄ±lÄ±klar oluÅŸturabiliriz.

â€“ Scoped: YapÄ±lan her requestâ€™te nesne tekrar oluÅŸur ve bir request iÃ§erisinde sadece bir tane nesne kullanÄ±lÄ±r. Bu yÃ¶ntem iÃ§in de AddScoped() metodu kullanÄ±lÄ±yor. Transient ve Scoped kullanÄ±m ÅŸekilleri nesne oluÅŸturma zamanlarÄ± aÃ§Ä±sÄ±ndan biraz karÄ±ÅŸtÄ±rÄ±labilir. Transientâ€™da her nesne Ã§aÄŸrÄ±mÄ±nda yeni bir instance oluÅŸturulurken, Scopedâ€™da ise request esnasÄ±nda yeni bir instance oluÅŸur ve o request sonlanana kadar aynÄ± nesne kullanÄ±lÄ±r. Request bazÄ±nda stateless nesne kullanÄ±lmasÄ± istenen durumlarda Scoped baÄŸÄ±mlÄ±lÄ±klarÄ± oluÅŸturabiliriz.

â€“ Singleton: ASP.NET Core uygulamasÄ± baÅŸlatÄ±ldÄ±ÄŸÄ±nda register edilen nesneye ait sadece bir tane instance oluÅŸur ve uygulamadaki her yerden bu referans Ã§aÄŸrÄ±lÄ±r. Uygulama yeniden baÅŸlatÄ±lana kadar bu nesne referansÄ± kullanÄ±lÄ±r, farklÄ± bir nesne referansÄ± ikinci kez oluÅŸturulmaz. Bu yÃ¶ntem iÃ§in de AddSingleton() metodunu kullanÄ±yoruz.



Local Storage: JavaScript sitelerinin ve uygulamalarÄ±nÄ±n son kullanma tarihi olmadan, bir web tarayÄ±cÄ±sÄ±nda key/value deÄŸerlerinin kaydedebilmesine izin veren bir Ã¶zelliktir.

Session Storage: Bir web tarayÄ±cÄ±sÄ±nda key/value deÄŸerlerini yalnÄ±zca bir oturum sÃ¼resi iÃ§in tarayÄ±cÄ±ya kaydedebilmesine izin veren bir Ã¶zelliktir. Yani tarayÄ±cÄ± sekmesi kapatÄ±ldÄ±ÄŸÄ±nda veriler de kaybolur
1)Aop Nedir
Aspect oriented programming kÄ±sa adÄ±yla AOP, uygulamanÄ±zdaki iÅŸ mantÄ±ÄŸÄ± (business logic) ile uygulamanÄ±zÄ±n genelinde ortak kullanÄ±labilecek olan yapÄ±larÄ±n ayrÄ±lmasÄ±nÄ± saÄŸlar. Ä°ÅŸ mantÄ±ÄŸÄ± haricindeki yapÄ±lara Ã¶rnek verecek olursak;
logging, exception handling, caching, authentication, authorization, transaction vb. iÅŸlemlerdir.
2)Oop Nedir Oop Prensibleri Nelerdir?.AÃ§Ä±kla
 Encapsulation prensibinin maksadÄ± classâ€™a ait propertyâ€™lere her classÄ±n istediÄŸi gibi eriÅŸmesini ve deÄŸiÅŸtirmesini engellemektir. EriÅŸim kÄ±sÄ±tlanmayacaksa bile eriÅŸimi getter/setter methodlarÄ± gibi yÃ¶ntemlerle kontrol altÄ±na almaktÄ±r
  Ä±nheritance: AdÄ±ndan tahmin edilebileceÄŸi Ã¼zere herhangi bir classâ€™Ä±n Ã¼st classâ€™larÄ±na ait olan method ve propertyleri kalÄ±tÄ±m yoluyla almasÄ±dÄ±r. 
  Abstraction:Daha derli toplu bir ifadeyle objelerin ayrÄ±ntÄ±larÄ±yla uÄŸraÅŸmak yerine yalnÄ±zca girdi ve Ã§Ä±ktÄ±larÄ±na odaklanarak tasarÄ±mÄ± daha iyi oluÅŸturmayÄ± ve anlamayÄ± saÄŸlamaktÄ±r.
  Polymorphism, (Ã§ok biÃ§imlilik) methodlarÄ±n objeye gÃ¶re farklÄ± Ã§Ä±ktÄ±lar Ã¼retmesi veya farklÄ± iÅŸler yapmasÄ±dÄ±r. Yani alÄ±ÅŸageldiÄŸimiz gibi methodlara sabit gÃ¶revler vermek yerine onlara Ã§ok biÃ§imli (polimorf) davranacak ÅŸekilde bir esneklik vermektir.
3)Solid ve solid Prensibleri
S â€” Single-responsibility principle
Ã–ZET: Bir sÄ±nÄ±f (nesne) yalnÄ±zca bir amaÃ§ uÄŸruna deÄŸiÅŸtirilebilir, o da o sÄ±nÄ±fa yÃ¼klenen sorumluluktur, yani bir sÄ±nÄ±fÄ±n(fonksiyona da indirgenebilir) yapmasÄ± gereken yalnÄ±zca bir iÅŸi olmasÄ± gerekir.

O â€” Open-closed principle
Ã–ZET: Bir sÄ±nÄ±f ya da fonksiyon halihazÄ±rda var olan Ã¶zellikleri korumalÄ± ve deÄŸiÅŸikliÄŸe izin vermemelidir. Yani davranÄ±ÅŸÄ±nÄ± deÄŸiÅŸtirmiyor olmalÄ± ve yeni Ã¶zellikler kazanabiliyor olmalÄ±dÄ±r.

L â€” Liskov substitution principle
Ã–ZET: KodlarÄ±mÄ±zda herhangi bir deÄŸiÅŸiklik yapmaya gerek duymadan alt sÄ±nÄ±flarÄ±, tÃ¼redikleri(Ã¼st) sÄ±nÄ±flarÄ±n yerine kullanabilmeliyiz.

I â€” Interface segregation principle
Ã–ZET: SorumluluklarÄ±n hepsini tek bir arayÃ¼ze toplamak yerine daha Ã¶zelleÅŸtirilmiÅŸ birden fazla arayÃ¼z oluÅŸturmalÄ±yÄ±z.

D â€” Dependency Inversion Principle
Ã–ZET: SÄ±nÄ±flar arasÄ± baÄŸÄ±mlÄ±lÄ±klar olabildiÄŸince az olmalÄ±dÄ±r Ã¶zellikle Ã¼st seviye sÄ±nÄ±flar alt seviye sÄ±nÄ±flara baÄŸÄ±mlÄ± olmamalÄ±dÄ±r.


4)KatmanlÄ± Mimari?
KatmanlÄ± mimari bir istemci-sunucu mimarisidir. UygulamayÄ± katmanlarÄ±na ayÄ±rarak geliÅŸtiricilere bir katmanÄ± dÃ¼zenleme veya Ã¶zel bir katman ekleme gibi seÃ§enekler sunan bir modeldir. Bu mimari n-tier architecture pattern olarak da bilinir. YazÄ±lÄ±m mÃ¼hendisliÄŸin de en Ã§ok kullanÄ±lan mimarilerden bir tanesidir. GeliÅŸtiricilerin esnek ve yeniden kullanÄ±labilir uygulamalar oluÅŸturmalarÄ±na olanak saÄŸlar. Her katmanÄ±n kendine Ã¶zgÃ¼ rolÃ¼ ve sorumluluÄŸu vardÄ±r. En Ã§ok kullanÄ±lan 3 katmanlÄ± mimaridir (three-tier architecture).

5)Clean Architecture?
Framework baÄŸÄ±msÄ±z
Test edilebilir
ArayÃ¼z baÄŸÄ±msÄ±z
VeritabanÄ± baÄŸÄ±msÄ±z
Hexogonal ve Onion mimarileri ile ayrÄ±ntÄ±larÄ±nda biraz farklÄ±lÄ±k gÃ¶sterseler de, birbirlerine Ã§ok benziyorlar. Ã‡Ã¼nkÃ¼ bu mimariler temelde aynÄ± amaca hizmet eder yani iÅŸlerimiz katmanlara ayÄ±rmamÄ±za.

Katmanlara neden ayÄ±rmalÄ±yÄ±z ?

Bu sorunun birden Ã§ok yanÄ±tÄ± var aslÄ±nda. Ã–ncelikle sistemimizin iÅŸ parÃ§acÄ±klarÄ±nÄ±n birbirinden ayrÄ±, herhangi bir deÄŸiÅŸiklikte diÄŸer parÃ§alarÄ± da deÄŸiÅŸtirmeyecek bir yapÄ±da olmasÄ±nÄ± isteriz. Tabi bu tek sebep deÄŸil projenin boyutu arttÄ±kÃ§a okunulabilir olmasÄ± da Ã§ok Ã¶nemlidir. Ä°ÅŸ parÃ§acÄ±klarÄ±nÄ± gerÃ§ekten birbirinden baÄŸÄ±msÄ±z yada bir diÄŸer adÄ±yla gevÅŸek baÄŸlÄ±lÄ±k(loose-coupling) yapmÄ±ÅŸ isek kolayca test yazabilir ve sonradan yapÄ±lan deÄŸiÅŸikliklerde sistemimizde herhangi bir sÄ±kÄ±ntÄ± olup olmadÄ±ÄŸÄ±nÄ± gÃ¶zlemleyebiliriz.

Katmanlar ğŸ“š
AÅŸaÄŸÄ±dan da gÃ¶rebileceÄŸiniz gibi katmanlarÄ±mÄ±z iÃ§ iÃ§e daireler ÅŸeklinde ilerliyor. Her bir daire sadece bir iÃ§teki daireye ihtiyaÃ§ duyar. Mesela Application katmanÄ±n baÄŸÄ±mlÄ±lÄ±ÄŸÄ± sadece Domain katmanÄ±dÄ±r.


Clean Architecture YapÄ±sÄ±
Ä°Ã§ daireden baÅŸlayarak dÄ±ÅŸarÄ±ya doÄŸru adÄ±m adÄ±m aÃ§Ä±klayarak ilerleyelim.

Domain KatmanÄ± ğŸ’¡
Domain katmanÄ±nda projenin kesinlikle ihtiyaÃ§ duyacaÄŸÄ± olmazsa olmazlarÄ±mÄ±zdan olan elemanlarÄ±mÄ±z olacak bunlar nedir ?

Entities

ORM araÃ§larÄ±nÄ±n geliÅŸmesiyle beraber proje iÃ§inde oluÅŸturduÄŸumuz sÄ±nÄ±flar ile veritabanÄ± oluÅŸturabilmemiz bu katmanda Ã§ok iÅŸimize yarÄ±yor.

YazÄ±m ASP.Net Ã¼zerine olduÄŸu iÃ§in burada kÃ¼Ã§Ã¼k bir not bÄ±rakmak istiyorum. VeritabanÄ± nesnelerinizi oluÅŸtururken Fluent API kullanmamÄ±z gerekiyor.

Value Object

Kendine ait eÅŸsiz bir kimliÄŸi olan nesneler Entity olarak adlandÄ±rÄ±lÄ±rken, kendine ait bir kimliÄŸi olmayanlar ise value object olarak adlandÄ±rÄ±lÄ±r. Immutable ve mutable kavramÄ±ndaki mutable: Entity ve immutable: Value Object olarak dÃ¼ÅŸÃ¼nebiliriz.

Logic

GerÃ§ekten domain ilgilendiren mantÄ±ksal iÅŸlemlerimiz

Exceptions

Domain iÃ§in oluÅŸturduÄŸumuz exception sÄ±nÄ±flarÄ±nÄ±n da bu katmanda olmasÄ± gerekiyor.

Burada asÄ±l Ã¶nemli olan belki de en Ã§ok kullanÄ±lan en azÄ±ndan benim kullandÄ±ÄŸÄ±m kÄ±sÄ±m Entities kÄ±smÄ±dÄ±r. DiÄŸerleri Ã§ok daha kompleks iÅŸlerde kullanÄ±labilir.

Application KatmanÄ± ğŸˆ¸
Gelelim Application katmanÄ±na, burasÄ± bizim genel olarak mantÄ±ksal iÅŸlemlerimizi yaptÄ±ÄŸÄ±mÄ±z katmandÄ±r. Ã–rnek olarak gelen isteklerin iÅŸlendiÄŸi validasyonlarÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± veritabanÄ± kayÄ±tlarÄ±nÄ±n yapÄ±ldÄ±ÄŸÄ± katmandÄ±r. KafanÄ±zda tam oturtturamamÄ±ÅŸ olabilirsiniz ama sorun deÄŸil detaylÄ± bir ÅŸekilde proje Ã¼zerinde gÃ¶receÄŸiz. Bu katmanÄ±n tek baÄŸlÄ±lÄ±ÄŸÄ± domain katmanÄ± olmalÄ±dÄ±r.

Interfaces

Mail servisi veya notification arayÃ¼zleri olabilir.

Models

Application katmanÄ±nda kullanacaÄŸÄ±nÄ±z modeller olabilir.

Logic Commands / Queries

BurasÄ± Ã¶nemli servise gelen isteklerin Request ve Response modellerini, bu servislerin mantÄ±ksal iÅŸlemlerini ve veritabanÄ± kayÄ±tlarÄ±nÄ±n bulunduÄŸu kÄ±sÄ±m.

Validators

Gelen isteklerin validasyonlarÄ± bulunur.

Exceptions

OluÅŸan hatalar iÃ§in de kiÅŸiselleÅŸtirdiÄŸimiz Exception sÄ±nÄ±flarÄ±mÄ±z bulunur.

â€¦

Gelen isteklerin bir okuma iÅŸlemi mi yoksa yazma iÅŸlemi mi durumlarÄ±na gÃ¶re farklÄ± modeller ve farklÄ± metotlar ile iÅŸlemlerimizi yaparÄ±z. KÄ±sacasÄ± okunabilir, dÃ¼zenlenebilir ve test edilebilir bir yapÄ± sunar. Bu tasarÄ±m kalÄ±bÄ±(CQRS) hakkÄ±nda daha detaylÄ± bilgi iÃ§in Microsoft Docs iÃ§inde gÃ¼zel bir yazÄ± var buradan ulaÅŸabilirsiniz. Uygulama iÃ§i mesajlaÅŸma iÃ§in ise MediatR, validasyon iÅŸlemleri iÃ§in ise FluentValidation paketini kullanacaÄŸÄ±z.

Persistence KatmanÄ± ğŸ«
Bu katman genel olarak DbContext iÅŸlemleriyle alakalÄ±dÄ±r. MigrationlarÄ±n yÃ¶netimi, veritabanÄ± tablolarÄ±nÄ±n configleri iÃ§in oluÅŸturulmuÅŸ Fluent API sÄ±nÄ±flarÄ± ve default veritabanÄ± deÄŸerleri. DbContext bu katmanda olmasÄ±na raÄŸmen hala veritabanÄ± baÄŸÄ±mlÄ±lÄ±ÄŸÄ±mÄ±z yoktur. ConnectionString AppSettings iÃ§inden eriÅŸilecek.

DbContext

Migrations

Configurations

Seeding

Infrastructure KatmanÄ± â•
Bu katmanda ise sisteme eklenecek external ÅŸeyler bulunur. Bu katmana hiÃ§bir katmanÄ±n baÄŸlÄ±lÄ±ÄŸÄ± olmamalÄ±dÄ±r.

Email / SMS

System Clock

Notification

Presentation KatmanÄ± ğŸ†
Bu katmanda isminden anlaÅŸÄ±lacaÄŸa Ã¼zere sunum katmanÄ±. Ben Web API projesinde Ã§alÄ±ÅŸtÄ±m. Bu katmanda mantÄ±ksal iÅŸlemler olmamalÄ±dÄ±r. O iÅŸ Application katmanÄ±nda olmalÄ±dÄ±r.

SPA - Angular veya React

Web API

MVC

Web Forms


6)Trigger,Views,Transaction,Callback,Indexers,Sql Crud-Sql Join?
Trigger yani tetikleyici, iliÅŸkisel veri tabanÄ± yÃ¶netim sistemlerinde bir tabloda belirli olaylar meydana geldiÄŸi zaman yani ekleme, gÃ¼ncelleme, silme iÅŸlemlerinden biri gerÃ§ekleÅŸmeden Ã¶nce veya sonra Ã§alÄ±ÅŸan ve belirli iÅŸlemleri kodlandÄ±ÄŸÄ± ÅŸekilde yerine getiren yordamdÄ±r.
View-Bir veritabanÄ±nda gÃ¶rÃ¼nÃ¼m, veritabanÄ± kullanÄ±cÄ±larÄ±nÄ±n kalÄ±cÄ± bir veritabanÄ± toplama nesnesinde olduÄŸu gibi sorgulayabileceÄŸi, veriler Ã¼zerinde depolanan bir sorgunun sonuÃ§ kÃ¼mesidir. Bu Ã¶nceden oluÅŸturulmuÅŸ sorgu komutu, veritabanÄ± sÃ¶zlÃ¼ÄŸÃ¼nde tutulur.
Transaction:Bir veritabanÄ± iÅŸlemi, bir veritabanÄ±na karÅŸÄ± bir veritabanÄ± yÃ¶netim sistemi iÃ§inde gerÃ§ekleÅŸtirilen, diÄŸer iÅŸlemlerden baÄŸÄ±msÄ±z olarak tutarlÄ± ve gÃ¼venilir bir ÅŸekilde ele alÄ±nan bir iÅŸ birimini sembolize eder. Bir iÅŸlem genellikle bir veritabanÄ±ndaki herhangi bir deÄŸiÅŸikliÄŸi temsil eder
Callback:Bir geri Ã§aÄŸÄ±rma fonksiyonu, baÅŸka bir fonksiyona geÃ§irilen bir parametre ÅŸeklindeki fonksiyondur.
Indexer:Indexer Ã¶zel tanÄ±mlÄ± bir property'dir ve sadece class iÃ§erisinde tanÄ±mlanabilir. TanÄ±mlandÄ±ÄŸÄ± class'a indexlenebilir Ã¶zelliÄŸi kazandÄ±rÄ±r. Array iÅŸlemlerinde kullandÄ±ÄŸÄ±mÄ±z [ ] operatÃ¶rÃ¼nÃ¼ tanÄ±mlamÄ±ÅŸ olduÄŸumuz bir class'Ä± diziymiÅŸ gibi iÅŸlemler yapabilmek iÃ§inde kullanabiliriz.
JOIN nedir?
Veri tabanÄ± tasarÄ±mÄ± ve tablo oluÅŸturma sÄ±rasÄ±nda tablolar Ã§eÅŸitli parÃ§alara ayrÄ±larak veri tekrarÄ±nÄ±n Ã¶nÃ¼ne geÃ§ilmiÅŸ olur.

ParÃ§alara ayrÄ±lan tablolar tek baÅŸÄ±na bir anlam ifade etmeyebilir.

ParÃ§alarÄ±n anlamlÄ± olabilmesi iÃ§in tablolarÄ±n birleÅŸtirme iÅŸlemine tabi tutulmasÄ± gerekir.

SQL JOIN ifadesi kullanÄ±larak tablolar sanal olarak birleÅŸtirilir ve veriler anlamlÄ± hale gelir.

Ã–zetle; SQL JOIN ifadesi, tablolarÄ± birleÅŸtirmek iÃ§in kullanÄ±lÄ±r.

NOT: JOIN iki veya daha fazla tabloyu birleÅŸtirmek iÃ§in kullanÄ±lÄ±r.

SQL JOIN kullanÄ±mÄ±
SQL join ifadesi kullanÄ±lan VTYS gÃ¶re deÄŸiÅŸmekle beraber genellikle aÅŸaÄŸÄ±daki gibidir.

SELECT tablo_adi.sutun_adi, ...
  FROM tablo_A
  {INNER JOIN | LEFT JOIN | RIGHT JOIN} tablo_B ON tablo_A.sutun_adi = tablo_B.sutun_adi;
AÅŸaÄŸÄ±daki Ã¶rnekleri kullanarak tablolarÄ± birleÅŸtirelim.

kategoriler tablosunda bulunan veriler:

kat_id	kat_adi
1	Bilgisayar
2	Telefon
3	Elektronik
urunler tablosunda bulunan veriler:

urun_id	urun_adi	urun_fiyat	kat_id
1	MasaÃ¼stÃ¼ Bilgisayar	1799	1
2	AkÄ±llÄ± Telefon	799	2
3	DizÃ¼stÃ¼ Bilgisayar	2199	1
4	SQL KitabÄ±	59	99
Ã–rneklerde bulunan kategoriler tablosu kat_id ile urunler tablosundaki kat_id adlarÄ±na ve deÄŸerlerine dikkat edin.

Ä°ki parÃ§aya ayrÄ±lan tablolarÄ± birleÅŸtirerek kategorilerde bulunan Ã¼rÃ¼nleri listeleyelim.

Bunun iÃ§in join kullanabileceÄŸimiz gibi iki tabloyu aÅŸaÄŸÄ±daki gibi sÄ±rayla yazarak birleÅŸtirebiliriz.

SELECT * FROM kategoriler, urunler;
Bu birleÅŸtirme tÃ¼rÃ¼ CROSS JOIN olarak adlandÄ±rÄ±lÄ±r.

Komut Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda iki tabloda bulunan veriler birbiriyle birleÅŸtirilecektir.

BirleÅŸtirme iÃ§in bir koÅŸul belirtilmediÄŸinden kategoriler tablosundaki her satÄ±r, urunler tablosundaki tÃ¼m satÄ±rlarla eÅŸleÅŸir.

KoÅŸul belirterek sadece iliÅŸkili olan sÃ¼tunlarÄ± birleÅŸtirmek iÃ§in WHERE koÅŸulu kullanÄ±labilir.

SELECT * FROM kategoriler, urunler WHERE urunler.kat_id = kategoriler.kat_id;
Bu birleÅŸtirme tÃ¼rÃ¼ INNER JOIN olarak adlandÄ±rÄ±lÄ±r.

SQL Join tÃ¼rleri
Ã‡oÄŸunlukla kullanÄ±lan join tÃ¼rleri ÅŸunlardÄ±r.

(INNER) JOIN: Ä°ki tablodaki eÅŸleÅŸen kayÄ±tlar iÃ§in kullanÄ±lÄ±r.
LEFT (OUTER) JOIN: Ä°ki tablodaki eÅŸleÅŸen kayÄ±tlar ve eÅŸleÅŸmeyen sol kayÄ±tlar iÃ§in kullanÄ±lÄ±r.
RIGHT (OUTER) JOIN: Ä°ki tablodaki eÅŸleÅŸen kayÄ±tlar ve eÅŸleÅŸmeyen saÄŸ kayÄ±tlar iÃ§in kullanÄ±lÄ±r.
FULL (OUTER) JOIN: Ä°ki tablodaki eÅŸleÅŸen kayÄ±tlar ve eÅŸleÅŸmeyen sol ve saÄŸ kayÄ±tlar iÃ§in kullanÄ±lÄ±r. LEFT ve RIGHT JOIN birleÅŸimidir.
SQL JOIN ayrÄ±ca ekleme, gÃ¼ncelleme ve silme iÅŸlemlerinde de kullanÄ±labilir.
7)DeÄŸer ve Referans Tipler
DeÄŸer tipindeki veri tipleri ile bir deÄŸiÅŸken tanÄ±mlandÄ±ÄŸÄ±nda deÄŸiÅŸkenin deÄŸeri Stack adÄ± verilen bellek bÃ¶lgesinde tutulur. Referans tipindeki veri tipinde bir deÄŸiÅŸken tanÄ±mlandÄ±ÄŸÄ±nda ise deÄŸiÅŸkenin deÄŸeri Heap bÃ¶lgesinde ve Heap bÃ¶lgesindeki deÄŸeri gÃ¶steren adres deÄŸeri ise Stack bÃ¶lgesinde tutulur.
8)SÄ±ralama AlgoritmalarÄ±?
SeÃ§meli SÄ±ralama (Selection Sort)
Eklemeli SÄ±ralama (Insertion Sort)
Kabuk SÄ±ralamasÄ± (Shell Sort)
BirleÅŸtirmeli SÄ±ralama (Merge Sort)
HÄ±zlÄ± SÄ±ralama (Quick Sort)
KabarcÄ±k SÄ±ralamasÄ± (Bubble Sort)
9)Generic Repository?

10)Generic Class ve Generic Tipler?
Genericâ€™ler tasarlandÄ±ÄŸÄ±mÄ±z interface, class, metod yada parametrelerin (argÃ¼manlarÄ±n) belirli bir tip iÃ§in deÄŸil bir ÅŸablon yapÄ±sÄ±na uyan her tip iÃ§in Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayan bir yapÄ±dÄ±r. 
11)Overload Nedir Ã–rnek Ver?
Overload kelime anlamÄ± olarak AÅŸÄ±rÄ± YÃ¼kleme anlamÄ±na gelmektedir. C# programlama dilinde overload dendiÄŸinde, aynÄ± isme sahip birden fazla metod akla gelir. Bu metodlar aynÄ± isimde olmalarÄ±na raÄŸmen, farklÄ± imzalara sahiptirler. Bu metodlarÄ±n imzalarÄ±nÄ± belirleyen unsurlar, parametre sayÄ±larÄ± ve parametre tipleridir.
12)Ä°nterface ve abstract farklarÄ± aÃ§Ä±kla?Ä°nterface ve abstract nedir?
Abstract Class	                                                        Interface
Constructor iÃ§erebilir.	                                                Constructor iÃ§eremez.
Static Ã¼yeler iÃ§erebilir.                                             	Static Ã¼yeler iÃ§eremez.
FarklÄ± tipte eriÅŸim belirleyici iÃ§erebilir.	                            EriÅŸim belirleyiciler kullanÄ±lmaz.Default olarak public kabul edilir
SÄ±nÄ±fÄ±n ait olduÄŸu kimliÄŸi belirtmek iÃ§in kullanÄ±lÄ±r.                 	SÄ±nÄ±fÄ±n yapabileceÄŸi kabiliyetleri belirtmek iÃ§in kullanÄ±lÄ±r.
Bir sÄ±nÄ±f sadece bir tane abstract sÄ±nÄ±fÄ± inherit edebilir.           	Bir sÄ±nÄ±f birden fazla interface'i sÄ±nÄ±fÄ± inherit edebilir.
TÃ¼retilen sÄ±nÄ±flar sÄ±nÄ±fÄ±n hepsini veya bir kÄ±smÄ±nÄ± da implement eder  	Ä°nterface ' i tamamen implement etmek zorundadÄ±r.
13)Forign key,Primary Key,Unic kEY NEDÄ°R Sql?
Unique Key (UNI / Tekil / Benzersiz Anahtar)
Unique Key (tekil anahtar), yer aldÄ±ÄŸÄ± tablo iÃ§erisinde bir deÄŸeri sadece bir kere alÄ±r. Ä°lgili deÄŸerin tekrar atanmasÄ±na izin verilmez. Ä°ÅŸlevi Primary Key (birincil anahtar) ile benzerlik taÅŸÄ±sa da, en Ã¶nemli farklÄ±lÄ±k Unique Keyâ€™in NULL deÄŸeri alabilir oluÅŸudur.

Primary Key (PRI / Birincil Anahtar)
Primary Key (birincil anahtar), bir veri tablosunda yer alan her satÄ±r iÃ§in bir vekil / tanÄ±mlayÄ±cÄ± (identify) gÃ¶revi gÃ¶rÃ¼r, kÄ±sÄ±tlamadÄ±r (constraint) ve eÅŸsizdir. SatÄ±rlara ait deÄŸerlerin karÄ±ÅŸmamasÄ± adÄ±na bu alana ait bilginin tekrarlanmamasÄ± gerekir. Temel iÅŸlevi, verilerin hangi satÄ±ra dizileceÄŸine (veya hangi satÄ±rda verilerin dÃ¼zenleneceÄŸine) karar vermesidir. Ã‡oÄŸunlukla tek bir alan (id, user_id, e_mail, username, national_identification_number vb.) olarak kullanÄ±lsa da birden fazla alanÄ±n birleÅŸimiyle de oluÅŸturulabilir ve genelde sayÄ±lar birincil anahtar olarak seÃ§ilirler, ancak zorunluluk deÄŸildir. Birincil anahtar deÄŸeri boÅŸ geÃ§ilemez ve NULL deÄŸer alamaz. Ä°liÅŸkisel veri tabanlarÄ±nda (relational database management system) mutlaka birincil anahtar olmalÄ±dÄ±r. Unutmadan, her birincil anahtar benzersiz iken her benzersiz anahtar birincil deÄŸildir. Benzersiz anahtar baÅŸlÄ±ÄŸÄ± altÄ±nda NULL kullanÄ±mÄ±na dair bir aÃ§Ä±klama dÃ¼ÅŸmÃ¼ÅŸtÃ¼m. Bu baÅŸlÄ±k altÄ±nda aradaki farklÄ±lÄ±klarÄ± biraz daha detaylandÄ±ralÄ±m;

Bir tablo iÃ§erisinde birden fazla alan tek bir birincil anahtar ile tanÄ±mlanabilir. Ancak, birincil anahtar yapÄ±sÄ± her tabloda sadece bir tane olabilir. Benzersiz anahtarda ise bÃ¶yle bir sÄ±nÄ±rlama yoktur.
Birincil anahtarda NULL kullanÄ±ma izin verilmez. Acnak, benzersiz anahtarlarda NULL kayÄ±tlara izin verilir.
Birincil anahtar ile veri tablosu Ã¼zerinde bir INDEX tanÄ±mÄ± oluÅŸturulur ve her kaydÄ±n benzersiz bir tanÄ±mÄ± yapÄ±lÄ±r. Benzersiz anahtar kullanÄ±mÄ±nda ise deÄŸerlerin benzersiz olup olmadÄ±ÄŸÄ±na bakÄ±lÄ±r. Elbette benzersiz anahtarlar da INDEX adÄ±yla tanÄ±mlanabilirler ancak bu sadece bir tanÄ±mlama olacaktÄ±r.
Foreign Key (YabancÄ± Anahtar)
Foreign Key (yabancÄ± anahtar) ikincil anahtar olarak da ifade edilmektedir. Bir veri tablosuna girilebilecek deÄŸerleri baÅŸka bir veri tablosundaki alanlarla iliÅŸkilendirmeye yarar. Ã–zetle, baÅŸka bir tablonun birincil anahtarÄ±nÄ±n bir diÄŸer tablo iÃ§erisinde yer almasÄ±dÄ±r. Ã‡oÄŸunlukla bir ana tablo (parent) ile alt tablonun (child) iliÅŸkilendirilmesinde kullanÄ±lÄ±r. Bu sayede olasÄ± veri tekrarlarÄ±nÄ±n Ã¶nÃ¼ne geÃ§ilebilmekte ve ilerleyen zamanda sÃ¶z konusu olabilecek gÃ¼ncellemelerde ilgili verilerin her yerde gÃ¼ncellenmesi saÄŸlanabilmektedir.
14)Orm Nedir? Ã–rnek ver?
ORM Nedir?
Ado.net kullanÄ±lan projelerde veritabanÄ± ile ilgili yapÄ±lan iÅŸlemlerde yazÄ±lÄ±mcÄ± doÄŸrudan sql sorgularÄ± yazmak durumundadÄ±r. ORM ile kod iÃ§erisine yazÄ±lan sql satÄ±rlarÄ± ortadan kalkmÄ±ÅŸtÄ±r. VeritabanÄ±mÄ±z iÃ§erisinde yer alan tablolar bir sÄ±nÄ±f (class), kolondaki alanlarÄ±mÄ±zÄ±n her biri deÄŸiÅŸken (property) olarak tanÄ±mlanmakta, veritabanÄ±ndaki kayÄ±tlara da ait olduÄŸu sÄ±nÄ±fta bir obje olarak eriÅŸebilmekte ve kullanabilmekteyiz.
Programlama dillerinin de kendine ait farklÄ± ORM frameworkâ€™leri bulunmaktadÄ±r.

Dillere gÃ¶re sÄ±k kullanÄ±lan ORM Ã¶rnekleri;

C#: Entity Framework,  Dapper, ECO, XPO, Norm
Java: Hibernate, Ebean, Torque, JPA,MyBattis
Php: CakePHP, Codelgniter, RedBean, Doctrine,Propel, PdoMap
Python: Django, South,Storm
15)Net ve Net Core FarklarÄ± Nelerdir?
.NET Core nedir?
.NET Core Microsoft tarafÄ±ndan geliÅŸtirilen .NET platformunun devamÄ± olan aÃ§Ä±k kaynak kodlu yazÄ±lÄ±m geliÅŸtirme platformudur.

.NET hakkÄ±nda detaylÄ± bilgiye .NET Nedir? yazÄ±mdan ulaÅŸabilirsiniz.

.NET yapÄ±sÄ± dilden baÄŸÄ±msÄ±z olarak geliÅŸtirilen bir platform olmasÄ±na raÄŸmen Microsoft tarafÄ±ndan sadece Windows iÅŸletim sisteminde Ã§alÄ±ÅŸabilir olarak dÃ¼zenlenmiÅŸti.

Microsoft 2016 yÄ±lÄ±na .NET ile platform baÄŸÄ±msÄ±z olarak geliÅŸtirmeye imkan veren .NET Core platformunu duyurdu.

Platform baÄŸÄ±msÄ±z
.NET Core platformu ile .NET platformu arasÄ±ndaki en Ã¶nemli fark platform baÄŸÄ±msÄ±z olarak geliÅŸtirme yapmaya imkan vermesidir.

Windows iÅŸletim sisteminde geliÅŸtirilen bir uygulama daha sonra Linux, Mac gibi iÅŸletim sistemlerinde de Ã§alÄ±ÅŸÄ±r.

AÃ§Ä±k kaynak
.NET Core Apache lisansÄ± altÄ±nda aÃ§Ä±k kaynak kodludur.

ModÃ¼ler
.NET Core platformu modÃ¼ler bir yapÄ±dadÄ±r.

.NET CLR yapÄ±sÄ± deÄŸiÅŸtirilerek CoreCLR olarak adlandÄ±rÄ±lan yeni bir CLR geliÅŸtirilmiÅŸtir.

Yeni CLR ile .NET iÃ§erisinde yer alan kÃ¼tÃ¼phaneler ihtiyaca gÃ¶re seÃ§ilerek geliÅŸtirme yapmaya imkan vermektedir.

Ã–ncelik
.NET platformunun Ã¶nceliÄŸi masaÃ¼stÃ¼ uygulamalar geliÅŸtirmek iken .NET Core platformunun Ã¶nceliÄŸi servis tabanlÄ± web uygulamalarÄ± geliÅŸtirmektir.

AyrÄ±ca .NET Core ile masaÃ¼stÃ¼ uygulamalarda geliÅŸtirilebilmektedir.

SonuÃ§
.NET Core platformunu kÃ¼tÃ¼phane ve iÃ§erik olarak .NET Framework platformundan herhangi bir farkÄ± yoktur.

Sadece .NET Framework iÃ§erisinde yer alan kÃ¼tÃ¼phaneler .NET Core platformuna belirli sÃ¼rÃ¼mlerle taÅŸÄ±nmÄ±ÅŸtÄ±r.

.NET platformunun .NET Core platformuna Ã§evrilmesindeki ana sebep platform baÄŸÄ±msÄ±z uygulama geliÅŸtirme ihtiyacÄ±dÄ±r.

Bu ihtiyaÃ§ ise bulut ve konteyner olarak adlandÄ±rÄ±lan teknolojilerin geliÅŸmesidir.

Yani geliÅŸtiricilerin .NET Framework platformunu aÃ§Ä±k kaynak olmasÄ±nÄ± istemesinden deÄŸil birÃ§ok firmanÄ±n bulut teknolojisine geÃ§mesidir.

AÃ§Ä±k kaynak olmasÄ±nÄ±n nedeni ise Java platformundaki ekosistemin .NET iÃ§inde olmasÄ±nÄ± saÄŸlamaktÄ±r.
16)Ä°ki eÅŸittir ve 3 eÅŸittir farklarÄ±?
Ä°ki eÅŸittir ve Ã¼Ã§ eÅŸittir arasÄ±ndaki en temel fark tip ve deÄŸer karÅŸÄ±laÅŸtÄ±rmasÄ±dÄ±r. ÃœÃ§ eÅŸittir kullandÄ±ÄŸÄ±nÄ±zda iki deÄŸerin hem tipini hem de deÄŸerini karÅŸÄ±laÅŸtÄ±rÄ±rken iki eÅŸittir ise deÄŸerlerin tiplerini eÅŸitleyerek sadece deÄŸer karÅŸÄ±laÅŸtÄ±rmasÄ± yapar.
17)Try Cathc Finally YapÄ±sÄ±?
try bloÄŸu iÃ§inde hesaplanacak ifade yer alÄ±r. Bu ifadenin hesaplanmasÄ±nda bir hata oluÅŸmamÄ±ÅŸsa, catch bloklarÄ± atlanarak programÄ±n Ã§alÄ±ÅŸmasÄ± finally bloÄŸu ile devam eder ve daha sonra programÄ±n bu bloÄŸu izleyen kÄ±smÄ±na geÃ§ilir.

try bloÄŸu iÃ§indeki iÅŸlemde bir hata oluÅŸmuÅŸsa, catch bloklarÄ±ndan hangisi bu hatayÄ± algÄ±layabiliyorsa o catch bloÄŸu iÃ§ine girilir ve gerekli hata mesajÄ± yazdÄ±rÄ±lÄ±r. Daha sonra program finally bloÄŸu ile yukarÄ±da aÃ§Ä±klandÄ±ÄŸÄ± biÃ§imde Ã§alÄ±ÅŸmaya devam eder.

 

NOT: finally bloÄŸu ne olursa olsun Ã§alÄ±ÅŸacaÄŸÄ±ndan burada genellikle try bloÄŸu iÃ§inde bellek hatalarÄ±na (memory leak gibi) ya da aÃ§Ä±k kalmÄ±ÅŸ baÄŸlantÄ±lara yol aÃ§abilecek deÄŸiÅŸkenler yok edilri.
18)Exception ve Exception Handgling?
Javada hata yakalama beÅŸ anahtar kelime ile yÃ¶netilir; try, catch, throw, throws ve finally. Hata aÃ§Ä±sÄ±ndan izlemek istediÄŸimiz kodlarÄ± try bloÄŸuna yazmalÄ±yÄ±z. try bloÄŸu iÃ§erisinde bir hata oluÅŸursa bu hata fÄ±rlatÄ±lÄ±r. FÄ±rlatÄ±lan hatayÄ± catch bloÄŸu yakalar. Sistem tarafÄ±ndan oluÅŸturulan hatalar otomatik olarak fÄ±rlatÄ±lÄ±r fakat bazÄ± durumlarda bizim de manuel olarak hata fÄ±rlatmamÄ±z gerekir, bu durumda throw ifadesi kullanÄ±lÄ±r. BazÄ± durumlarda yazdÄ±ÄŸÄ±mÄ±z metodun hangi hatalarÄ± fÄ±rlatabileceÄŸini metod imzasÄ±nda belirtmemiz gerekir. Bu durumda throws ifadesi kullanÄ±lÄ±r. Bir try bloÄŸundan sonra hata olsun olmasÄ±n mutlaka yapÄ±lmasÄ± gereken bir iÅŸ varsa o da finally bloÄŸunda yapÄ±lÄ±r.

try ve catch bloÄŸunun genel yapÄ±sÄ± aÅŸaÄŸÄ±daki gibidir. try tek baÅŸÄ±na kullanÄ±labilir ama catch ifadesi sadece try ile birlikte kullanÄ±labilir.
19)Garbrage Collector nedir?
Bilgisayar Biliminde garbage collection kaynak yÃ¶netiminin Ã¶zel bir adÄ±mÄ±dÄ±r. Bilgisayar hafÄ±zasÄ±nÄ±n yÃ¶netilmesi iÅŸleminde kullanÄ±lmaktadÄ±r. Bilgisayar programlarÄ± Ã§alÄ±ÅŸma zamanÄ± sÄ±rasÄ±nda bellek ihtiyacÄ± duyarlar ve ihtiyaÃ§ duyulmayan hafÄ±za alanlarÄ± programlar tarafÄ±ndan iÅŸletim sistemine iade edilir.
20)Ioc nedir Ä±nversion of controller ? ornek ver?
IoC(Inversion Of Control), uygulamanÄ±n yaÅŸam dÃ¶ngÃ¼sÃ¼ boyunca birbirine baÄŸÄ±mlÄ±lÄ±ÄŸÄ± az (loose coupling) olan nesneler oluÅŸturmayÄ± amaÃ§layan bir yazÄ±lÄ±m geliÅŸtirme prensibidir. Nesnelerin yaÅŸam dÃ¶ngÃ¼sÃ¼nden sorumludur, yÃ¶netimini saÄŸlar. IoC kullanan sÄ±nÄ±fa bir interface inject edildiÄŸinde, ilgili interface metotlarÄ± kullanÄ±labilir olur. BÃ¶ylece IoC kullanan sÄ±nÄ±f sadece kullanacaÄŸÄ± metotlarÄ± bilir, sÄ±nÄ±f iÃ§erisinde daha fazla metot olsa bile interfaceâ€™de belirtilen metotlara eriÅŸebilecektir.

SÄ±nÄ±f iÃ§erisinde yapÄ±lacak herhangi bir deÄŸiÅŸiklikte IoC kullanan sÄ±nÄ±f etkilenmeyeceÄŸi iÃ§in yeniden yazÄ±labilir ve test edilebilir yazÄ±lÄ±m geliÅŸtirmemizi saÄŸlar. IoC nesne baÄŸlamalar genellikle uygulama baÅŸlangÄ±cÄ±nda yapÄ±landÄ±rÄ±lmaktadÄ±r. Bu anlamda tek bir yerden yapÄ±lan IoC yapÄ±landÄ±rmalarÄ±nÄ±n deÄŸiÅŸtirilmesi ve yÃ¶netimi de oldukÃ§a kolaydÄ±r.

IoC kullanmanÄ±n avantajlarÄ±nÄ± ÅŸÃ¶yle sÄ±ralayabiliriz:

Loosely coupled (baÄŸÄ±mlÄ±lÄ±ÄŸÄ± az) sÄ±nÄ±flar oluÅŸturma
Kolay unit test yazma
YÃ¶netilebilirlik
ModÃ¼ler programlar
FarklÄ± implementasyonlar arasÄ± kolay geÃ§iÅŸ
21)Let ,cons,any,var kavramlarÄ±nÄ± aÃ§Ä±kla?
Var
Kapsam: Function Scope.
Function iÃ§inde var kullanÄ±larak tanÄ±mlanmÄ±ÅŸ deÄŸiÅŸkenlere fonksiyon dÄ±ÅŸÄ±nda eriÅŸim saÄŸlanamaz.
TanÄ±mlanan deÄŸiÅŸkenler sonradan deÄŸiÅŸtirilebilir.
DeÄŸiÅŸkenler kodun herhangi bir yerinde birden fazla kez kullanÄ±labilir.
BaÅŸlatmadan bildirilebilir.
VarsayÄ±lan deÄŸeri â€œundefinedâ€ yani tanÄ±msÄ±z olduÄŸu iÃ§in baÅŸlatma yapÄ±lmadan eriÅŸilebilir.
Let
Kapsam: Block Scope.
TanÄ±mlandÄ±ÄŸÄ± kapsam iÃ§erisinde eriÅŸilebilir ve bunun dÄ±ÅŸÄ±nda eriÅŸilemezler.
Sonradan tekrar deÄŸiÅŸtirilebilir.
Fakat aynÄ± kapsam iÃ§erisinde yalnÄ±zca bir sefer tanÄ±mlanabilir.
BaÅŸlatmadan bildirilebilir.
Bir â€œerrorâ€ yani hata dÃ¶ndÃ¼rdÃ¼ÄŸÃ¼ iÃ§in baÅŸlatma olmadan eriÅŸilemez.
Const
Kapsam: Block Scope.
TanÄ±mlandÄ±ÄŸÄ± kapsam iÃ§inde eriÅŸilebilir ve bunun dÄ±ÅŸÄ±nda eriÅŸilemezler.
Sonradan deÄŸiÅŸtirilemez.
AynÄ± kapsam iÃ§inde yalnÄ±zca bir sefer tanÄ±mlanabilir.
BaÅŸlatma olmadan bildirilemez.
BaÅŸlatma olmadan bildirilemeyeceÄŸi iÃ§in baÅŸlatma olmadan eriÅŸilemez.
HatÄ±rlatma
Block Nedir?
Blok, {â€¦} ile sÄ±nÄ±rlandÄ±rÄ±lmÄ±ÅŸ bir kod parÃ§asÄ±dÄ±r. KÄ±vrÄ±mlÄ± parantezler iÃ§indeki herhangi bir ÅŸey bir bloktur.
Hoisting Nedir?
Hoisting, Interpreterâ€™Ä±n Ã¶nce tanÄ±mlanan ÅŸey hakkÄ±nda hafÄ±zada yer aÃ§masÄ± anlamÄ±na gelir.
Hoisting, Javascriptâ€™te deÄŸiÅŸkenlerimizin baÅŸta tanÄ±mlanmasÄ± iÅŸlemidir. Hoisting olayÄ±nÄ±n temel amacÄ± aÅŸaÄŸÄ±da tanÄ±mladÄ±ÄŸÄ±nÄ±z deÄŸiÅŸkenlere yukardan veya herhangi bir yerden rahat bir ÅŸekilde ulaÅŸmanÄ±zdÄ±r.
22)HtmlIntercaptor nedir?
Interceptorâ€™lar client tarafÄ±ndan sunucuya giden requestlerin modifiye edilerek sunucuya ulaÅŸmasÄ±nÄ± saÄŸlar. Interceptorâ€™lar sayesinde requestlerâ€™e mÃ¼dehale ederiz ve bu da bir Ã§ok noktada bize pratiklik saÄŸlar. Åimdi bunu Ã¶rnekler anlatmaya baÅŸlayalÄ±m.
23)MiddleWare Nedir?
Middleware, birbirleri ile iletiÅŸim halindeki uygulamalar arasÄ±nda, tekrar eden gÃ¶revleri gerÃ§ekleÅŸtirmek amacÄ±yla yer alan ara yazÄ±lÄ±mlardÄ±r. Tek baÅŸlarÄ±na bir iÅŸlem gerÃ§ekleÅŸtirmezler. Ã–rneÄŸin, daÄŸÄ±tÄ±lmÄ±ÅŸ uygulamalar iÃ§in iletiÅŸim ve veri yÃ¶netimini saÄŸlayabilirler. Ancak, doÄŸrudan bir iletiÅŸim baÅŸlatmazlar ya da veri alÄ±ÅŸveriÅŸi gerÃ§ekleÅŸtiremezler3.

Ã–zetlemek gerekirse, middleware (ara uygulama veya orta katman) aracÄ±lÄ±ÄŸÄ± ile bir web sunucusu kullanÄ±cÄ±nÄ±n profili ile iliÅŸkili olarak dinamik web sayfalarÄ± dÃ¶ndÃ¼rebilir. Burada kullanÄ±cÄ±nÄ±n oturum/kimlik yÃ¶netimini ara uygulama ele alÄ±r. Klasik bir web uygulamasÄ±nda kullanÄ±cÄ± istek gÃ¶nderir ve karÅŸÄ±lÄ±ÄŸÄ±nda sunucundan bir cevap alÄ±r. GeliÅŸmiÅŸ bir yapÄ±da ise istek ara uygulamaya iletilir. 
24)Component Nedir?
View Component bizim iÃ§in yeni bir terimdir. Asp.Net Core ile hayatÄ±mÄ±za giriÅŸ yapmÄ±ÅŸtÄ±r. Peki nedir bu view component ve niÃ§in kullanÄ±rÄ±z ?

View Component

Daha Ã¶nceden Asp.Net MVC kullananlar bilir oradaki partial view'e benzemektedir ve Partial viewden daha iyidir.(Microsoft diyor ve bence haklÄ±lar da)

Birden Ã§ok  view'de kullanÄ±labilir ve yeniden kullanÄ±labilir birleÅŸen(component) yazmamÄ±zÄ± saÄŸlar.

Asenkron olarak kullanabiliriz.

Url'den ulaÅŸÄ±lamaz.(Asp Net MVC de partial view'imizin adÄ±nÄ± url'den yazarak ulaÅŸÄ±labiliyorduk. Url'den ulaÅŸÄ±labilir olmasÄ±nÄ± istemediÄŸimiz zamansa ChieldOnly attribute kullanÄ±yorduk ve url Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda ulaÅŸÄ±lamÄ±yordu ve bize hata fÄ±rlatÄ±yordu.)

Test edilmesi kolay bir yapÄ±sÄ± vardÄ±r.

View Component Nerelerde KullanÄ±lÄ±r? Ã–rnek olarak;

Dinamik menÃ¼ler,

Login paneli,

AlÄ±ÅŸveriÅŸ sepeti,

En son yazÄ±lar gibi vb. yapÄ±larda kullanabiliriz.
25)Statik Metot,Virtual Metot?
Virtual metotlar kalÄ±tÄ±m yolu ile aktarÄ±ldÄ±klarÄ± sÄ±nÄ±flarÄ±n iÃ§erisinde override edilerek deÄŸiÅŸtirilebilirler. EÄŸer override edilmezlerse temel sÄ±nÄ±f iÃ§erisinde tanÄ±mlandÄ±klarÄ± ÅŸekilde Ã§alÄ±ÅŸÄ±rlar.
Statik metot Main(), herhangi bir nesne oluÅŸturulmadan Ã¶nce Ã§aÄŸÄ±rÄ±lmasÄ± gerektiÄŸi iÃ§in static olarak tanÄ±mlanmÄ±ÅŸtÄ±r. BaÅŸka bir deyiÅŸle de bir nesne metodun Ã¼reteceÄŸi sonucu etkilemeyecek ise o metot static olarak tanÄ±mlanÄ±r.
26)SÄ±nÄ±flar ArasÄ± Ã‡oklu KalÄ±tÄ±m Yoktur Sadece Ã‡oklu KalÄ±tÄ±m Ä°nterfacelerde VardÄ±r?
27)This anahtar sozcÃ¼ÄŸÃ¼?
this anahtarÄ±:YapÄ±cÄ± metod iÃ§erisinden yukarÄ±da tanÄ±mlanan nesne deÄŸiÅŸkenlerine eriÅŸilmek istenirse this anahtar kelimesi kullanÄ±lÄ±r. this kelimesi, o anda Ã¼zerinde iÅŸlem yapÄ±lan nesnenin referansÄ±nÄ± dÃ¶ndÃ¼rÃ¼r ve bÃ¶ylece nesne deÄŸiÅŸkenlerine eriÅŸmiÅŸ oluruz.
28)Extension Metot Nedir?
Kelime anlamÄ± geniÅŸletilebilir metod olan Extension Method'lar C#3.0 ile hayatÄ±mÄ±za girmiÅŸtir ve yaptÄ±ÄŸÄ± iÅŸ itibatiyle kullanÄ±m aÃ§Ä±sÄ±ndan son derece faydalÄ± metodlardÄ±r. Tek cÃ¼mleyle Ã¶zetlemek gerekirse class ve struct yapÄ±larÄ±nÄ± modify etmeden ilgili struct yada class'iÃ§in extension metodlar eklememizi saÄŸlar.

 Extesion metod yazarken uymamÄ±z gereken bir kaÃ§ kural vardÄ±r. Bunlar;

Extension metodlar static bir class iÃ§erisinde static olarak tanÄ±mlanmalÄ±dÄ±r. 
Extend edilecek class ilgili extension metoda metodun ilk parametresi olarak verilip Ã¶nÃ¼nde this keyword'Ã¼ ile tanÄ±mlanmalÄ±dÄ±r
Extension metod da tanÄ±mlÄ± parametrelerden sadece 1 tanesi this keyword'Ã¼ ile tanÄ±mlanÄ±r
29)Sanal SÄ±nÄ±flardan Nesne Uretilebilir Mi?  
HayÄ±r nesne tÃ¼retilemez
30)Restful Servis Nedir.
Httpp Ã¼zerinden client ve server aracaÄ±lÄ±ÄŸÄ± iÅŸletiÅŸim kuran yapÄ±lar put delete,putch,post,get gibi
31)Api Nedir?Restfull Api Nedir?
REST API nedir ne iÅŸe yarar?
REST API, istemci ve sunucu arasÄ±nda XML, JSON, HTML, TEXT baÅŸta olmak Ã¼zere pek Ã§ok formatta veri taÅŸÄ±yarak uygulamalarÄ±n haberleÅŸmesini saÄŸlar. REST standartlarÄ±na uygun yazÄ±lan web servislerine RESTful servisler denir.
API Nedir?
API'ler, iki yazÄ±lÄ±m bileÅŸeninin belirli tanÄ±mlar ve protokoller aracÄ±lÄ±ÄŸÄ±yla birbiriyle iletiÅŸim kurmasÄ±na olanak tanÄ±yan mekanizmalardÄ±r. Ã–rneÄŸin, meteoroloji mÃ¼dÃ¼rlÃ¼ÄŸÃ¼nÃ¼n yazÄ±lÄ±m sistemi, gÃ¼nlÃ¼k hava durumu verilerini iÃ§erir. Telefonunuzdaki hava durumu uygulamasÄ±, API'ler aracÄ±lÄ±ÄŸÄ±yla bu sistemle "konuÅŸur" ve telefonunuzda size gÃ¼nlÃ¼k hava durumu gÃ¼ncellemelerini gÃ¶sterir.
32)IactionResult,ViewResult?jSONresult,StatusCodeResult?
View view dÃ¶newr wjson json dÃ¶newr Ä±action temel sÄ±nÄ±f status da http code dÃ¶ner redirect de kontrolle ve actiona yÃ¶nlendirir.
33)Mvc nedir?
Model: TasarÄ±mÄ±n en alt kÄ±smÄ±dÄ±r. Veriyi yÃ¶netmek ile gÃ¶revlidir.
View: KullanÄ±cÄ±ya verinin tamamÄ±nÄ± veya belirli kÄ±sÄ±mlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemekten sorumludur.
Controller: Model ve view arasÄ±ndaki etkileÅŸimleri kontrol eder.
34)Postgresql in Mssql den farklarÄ±?
Postgresql Ã¼cretiss mssql Ã¼cretli
35)Modern Js Frameworkleri?
Angular,Vue,React
36)Framework ve library Nedir?
Framewworwk uygulama Ã§atÄ±sÄ± dÄ±r uygulamayÄ± o yapÄ±ya gÃ¶re deÄŸiÅŸtiririz librarde mettotlar topluluÄŸudur.
37)Organizasyon KÃ¼ltÃ¼rÃ¼ Nedir
Sirkete alÄ±ÅŸtÄ±kÃ§a rahatlamalar giriÅŸ Ã§Ä±kÄ±ÅŸ saatlerinde esneklik gibi
39)Veri tabanÄ± iliÅŸkilendirmesi sanal olarak Ã¶rnekle?
Bire bir coka cok bire cok
40)Code first ve Dbfirst Nedir?Hangisini kullanÄ±yorsunuz?
Code first migration yapÄ±snÄ± kullanÄ±r veri tabanÄ±nÄ± kodla otomatik oluÅŸturur.Db First de ise veri tabanÄ±nÄ± Ã¶nce oluÅŸturup iliÅŸkilendirmelerini yaparÄ±z sonra modelleriz:
41)Dtos nedir?Automapper Nedir?
Automapper: Veri tabanÄ±ndaki tabloyla benim classlarÄ±m arasÄ±nda bazÄ± yerlerin kapsullenmesini saÄŸlayan kÃ¼tÃ¼phane
En baÅŸta DTO yani Data Transfer Object kullanÄ±m alanÄ±nÄ± aÃ§Ä±klamak gerekirse, bir kaynaktan aldÄ±ÄŸÄ±mÄ±z veriyi, kullanacaÄŸÄ±mÄ±z yere gÃ¶re hazÄ±rladÄ±ÄŸÄ±mÄ±z sÄ±nÄ±flara DTO denir. Bu dil baÄŸÄ±msÄ±z bir yÃ¶ntemdir.

Verilerimizi her zaman veritabanÄ±nda sakladÄ±ÄŸÄ±mÄ±z gibi gÃ¶stermek istemeyebiliriz. Ã–rnek vermek gerekirse veritabanÄ±nda bir mÃ¼ÅŸterinin adÄ±nÄ± ve soyadÄ±nÄ± farklÄ± alanlarda tutup, UIâ€™da birleÅŸik gÃ¶stermek iÃ§in DTO sÄ±nÄ±flarÄ± oluÅŸtururuz yada bir tablonun CRUD iÅŸlemleri iÃ§in farklÄ± DTOâ€™lar oluÅŸturabiliriz.
Lazy Loading

Lazy Loading, sayfada yer alan bir Ã¶genin ihtiyaÃ§ duyulmadÄ±ÄŸÄ± takdirde Ã§aÄŸrÄ±lmamasÄ± prensibi ile Ã§alÄ±ÅŸÄ±r yani bir nesne Ã¶rneÄŸinin gerÃ§ekten ihtiyaÃ§ duyulacaÄŸÄ± ana kadar alÄ±nmamasÄ± ve bekletilmesi amacÄ±yla kullanÄ±lÄ±r. Bu yÃ¶ntemde veriler sorguya baÄŸlÄ± olarak Ã§ekilir ve veri setinin iÃ§indeki tÃ¼m datalarÄ± yÃ¼klemek yerine kullanÄ±lacaÄŸÄ± an tekrar sorgu atar ve veriyi Ã§eker.
Eager Loading

Lazy Loadingâ€™in tam tersi yÃ¶nde Ã§alÄ±ÅŸÄ±r. KullanacaÄŸÄ±mÄ±z nesneleri, nesnenin ihtiyaÃ§ anÄ±ndan Ã§ok Ã¶nce yaratÄ±r ve bekletir. Eager loading Linq sorgusu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda verilerin tamamÄ±nÄ± yÃ¼kler ve hafÄ±zaya alÄ±r.
Rabbit mq:TanÄ±m olarak Mesaj KuyruÄŸu sistemi diyebiliriz, tabi burada mesaj kuyruÄŸundan kastÄ±mÄ±z herhangi bir iÅŸlem (process) olabilir. Genelde mesajlaÅŸma sistemlerinde kullanÄ±lmaya baÅŸlansa da zaman iÃ§erisinde deÄŸiÅŸen ihtiyaÃ§lardan dolayÄ± projelerin Ã¶lÃ§eklerinin bÃ¼yÃ¼mesi, yoÄŸun istek(request) almalarÄ± , gelen isteklere cevap (response) zamanÄ± uzamasÄ± gibi durumlardan dolayÄ± kullanÄ±cÄ± kitlelerinin kaybedilmemesi, hizmetlerin aksamasÄ±nÄ±n ve ihtiyaÃ§lardan dolayÄ± kullanÄ±m alanlarÄ± gitgide geniÅŸledi. BankalarÄ±n kullandÄ±ÄŸÄ± EFT vb. iÅŸlemlerde, yoÄŸun istek (request) alan e-ticaret sistemlerinin olmazsa olmazÄ± haline geldi.

Somut olarak; Postane veya Kargo firmasÄ± gibi dÃ¼ÅŸÃ¼nebiliriz.

â€œProcess olarak bilgi (nesne) kargoya verilir, kargo firmasÄ± (kendi iÅŸ akÄ±ÅŸlarÄ± doÄŸrultusunda) iÅŸleme alÄ±r ve gÃ¶ndericiye ulaÅŸtÄ±rÄ±lÄ±r, kargo ulaÅŸana kadar siz kendi iÅŸlerinizi yapmaya devam edersiniz kargonun gÃ¶nderilmesini beklemeyiz.â€

Benim karÅŸÄ±laÅŸtÄ±ÄŸÄ±m ve RabbitMQ kullanmamÄ± gerektiren durumlara Ã¶rnek vermek gerekirse;
* E-mail gÃ¶nderimi iÅŸlemlerinde
* HazÄ±r rapor sorgularÄ±nÄ±n dÄ±ÅŸÄ±nda ihtiyaca gÃ¶re (anlÄ±k) oluÅŸturulan parametrelerinin deÄŸiÅŸkenlik gÃ¶steren dinamik raporlama iÅŸlemlerde kullandÄ±m.

â€œRapor iÃ§in kullanÄ±cÄ±dan seÃ§tiÄŸi parametre ve bu parametreye baÄŸlÄ± ÅŸartlar doÄŸrultusunda oluÅŸturulan talep queue de saklanÄ±r, Consumerâ€™in dinlediÄŸi kuyruktan istek raporu byte[] ÅŸeklinde saklanan veri JSON ile istenilen tipe dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lerek veri gerekli veri kaynaÄŸÄ±ndan Ã§ekilir, kullanÄ±cÄ± isteÄŸine gÃ¶re xml-xls-txt vb. tÃ¼rÃ¼nde kullanÄ±cÄ±ya response olarak geri dÃ¶nÃ¼lÃ¼r.â€

RabbitMQ asenkron ÅŸekilde Ã§alÄ±ÅŸan bir yapÄ±dÄ±r. Erlang programlama dili ile geliÅŸtirilmiÅŸtir.

RabbitMQ Kurulumu
RabbitMQ Erlang programlama dili ile geliÅŸtirildiÄŸinden bahsetmiÅŸtik.

Ä°lk adÄ±m olarak http://erlang.org/download/ adresten istenilen versiyonu seÃ§erek (.exe) kurulumu yapalÄ±m.
Ä°kinci adÄ±mda https://www.rabbitmq.com/install-windows.html adresinden RabbitMQ kurulumu yapalÄ±m.
RabbitMQ KonfigÃ¼rasyon
Ortam deÄŸiÅŸkenlerine (Environment variables) RabbitMQ node name ekleyelim.

RabbitMQ kurulumunu yaptÄ±ÄŸÄ±mÄ±z makine-bilgisayarâ€™Ä±n host name ile RabbitMQ node name aynÄ± olmalÄ±dÄ±r.

Ortam deÄŸiÅŸkenlerini aÃ§mak iÃ§in.

BilgisayarÄ±m-(This PC) => SaÄŸ tÄ±k => Ã–zellikler (Properties)


Bu ekranda Advanced system settings (GeliÅŸmiÅŸ sistem AyarlarÄ±) tÄ±klanÄ±r ve system properties ekranÄ± aÃ§Ä±lÄ±r.


Advanced (GeliÅŸmiÅŸ) sekmesinden Enviroment Variables (ortam deÄŸiÅŸkenlerine) tÄ±klayalÄ±m.
Advanced (GeliÅŸmiÅŸ) sekmesinden Environment Variables (ortam deÄŸiÅŸkenlerine) tÄ±klayalÄ±m.


ademolguner1903 value deÄŸeri benim RabbitMQ kurmuÅŸ olduÄŸum bilgisayarÄ±mÄ±n host name bilgisidir. Siz de aynÄ± ÅŸekilde kurulumu yapmÄ±ÅŸ olduÄŸunuz makineye ait host name bilgisini girerek ekleyelim.

Bir sonraki konfigÃ¼rasyon iÅŸlemi iÃ§in Windows tuÅŸuna basÄ±p arama kÄ±smÄ±na â€œRabbitMQ Command Promptâ€ yazarak arayalÄ±m.


RabbitMQ Command Promptâ€™a tÄ±klayalÄ±m ve karÅŸÄ±mÄ±za Ã§Ä±kan ekran:


RabbitMQ kurulumlarÄ±ndan sonra RabbitMQ Plugin-Servisini aktif etmek iÃ§in komut satÄ±rÄ± dizesine alttaki komutu yazalÄ±m ve Servis-Pluginâ€™i aktifleÅŸtirilmiÅŸ olur.

rabbitmq-plugins enable rabbitmq_management


Kurulum ve konfigÃ¼rasyon iÅŸlemlerini tamamladÄ±k RabbitMQ iÃ§in browserâ€™a 15672 portundan artÄ±k eriÅŸebiliriz.

http://localhost:15672


http://localhost:15672
KarÅŸÄ±mÄ±za local makinemize kurmuÅŸ olduÄŸumuz RabbitMQ login ekranÄ± gelecektir. RabbitMQ kurulumunda varsayÄ±lan olarak kullanÄ±cÄ± adÄ± ve ÅŸifre tanÄ±mlanmÄ±ÅŸ olarak gelir.

UserName: guest
Password : guest

VarsayÄ±lan olarak gelen bu kullanÄ±cÄ± adÄ± ve ÅŸifre bilgilerini gÃ¼ncelleyebilir veya birden Ã§ok kullanÄ±cÄ± oluÅŸturabiliriz.

Yeni KullanÄ±cÄ± ve ÅŸifre oluÅŸturma, yetkilendirme iÅŸlemlerini alttaki komutlar ile yapabiliriz.

rabbitmqctl add_user test test
rabbitmqctl set_user_tags test administrator
rabbitmqctl set_permissions -p / test â€œ.*â€ â€œ.*â€ â€œ.*â€
rabbitmqctl change_password test test

Login iÅŸlemlerinden sonra RabbitMQ sunucusuna ait paneli gÃ¶rÃ¼ntÃ¼lenmektedir. Nodes, Connections, Channels, Exchanges, Queues vb. ekranlarÄ± gÃ¶rÃ¼ntÃ¼leyebiliriz.


RabbitMQ ve BileÅŸenleri
https://www.rabbitmq.com/tutorials/amqp-concepts.html
https://www.rabbitmq.com/tutorials/amqp-concepts.html
1- Publisher: KuyruÄŸa mesaj gÃ¶nderen uygulamadÄ±r.
2- Consumer: KuyruÄŸu dinleyen uygulamadÄ±r.
3- RabbitMQ
* Routing key: MesajÄ±mÄ±zÄ± yÃ¶nlendireceÄŸimiz anahtarÄ±mÄ±zdÄ±r.
* Exchange: MesajÄ± ilgili â€œrouting keyâ€e gÃ¶re ilgili queueâ€™ya yÃ¶nlendiren bÃ¶lÃ¼m
* Queue: MesajlarÄ±n son olarak dÃ¼ÅŸtÃ¼ÄŸÃ¼ kuyruk
* Exchange type: Gelen mesajÄ±n, â€œrouting keyâ€e gÃ¶re hangi queueâ€™ya â€œnasÄ±lâ€ gÃ¶nderileceÄŸini belirtir.

Exchange Types
1- Direct Exchange: â€œrouting keyâ€ (yÃ¶nlendirme anahtarÄ±) belirlenir ve bu anahtar bilgisi kuyruÄŸa yazÄ±lÄ±r. â€œconsumerâ€ tarafÄ±ndan da bu anahtarlara gÃ¶re iÅŸlem yapÄ±lÄ±r.


2- Fanout Exchange: Mesajlar â€œexchangeâ€ de yer alan bÃ¼tÃ¼n kuyruklara gÃ¶nderilir. Sadece yÃ¶nlendirme anahtarÄ± (Routing Key) olanlar gÃ¶z ardÄ± edilir.


3- Topic Exchange: verilen yÃ¶nlendirme anahtarlarÄ±na gÃ¶re farklÄ± kuyruklara yazma iÅŸlemleri rabbit exchange topic ile yapÄ±labilir ve bu yazÄ±lan mesajlar â€œconsumerâ€ lar tarafÄ±ndan direk yÃ¶nlendirme anahtarÄ±na gÃ¶re veya (*) ile eriÅŸilebilir. AyrÄ±ca (#) ile â€œexchangeâ€ de bulunan bÃ¼tÃ¼n kuyruklara ait mesajlarÄ± yakalamak mÃ¼mkÃ¼n.

erkek.liked -> Erkeklerin beÄŸendikleri
erkek.unliked -> Erkeklerin beÄŸenmedikleri
kadin.liked -> KadÄ±nlarÄ±n beÄŸendikleri
kadin.unliked -> KadÄ±nlarÄ±n beÄŸenmediÄŸi Ã¼rÃ¼nler
erkek.* -> Erkeklerin beÄŸendiÄŸi ve beÄŸenmediÄŸi herÅŸey
kadin.* -> KadÄ±nlarÄ±n beÄŸendiÄŸi ve beÄŸenmediÄŸi herÅŸey
*.liked -> BÃ¼tÃ¼n beÄŸenilenler
*.unliked -> BÃ¼tÃ¼n beÄŸenilmeyenler
# -> HerÅŸey


4- Headers Exchange: Topic exchangeâ€ in benzeridir. YÃ¶nlendirme anahtarlarÄ± yerine mesajlar â€œheaderâ€ iÃ§erir ve kuyruk eÅŸleÅŸtirmesi gÃ¶nderilen header lara gÃ¶re yapÄ±lÄ±r.
Redis:
Redis, geliÅŸtiriciler tarafÄ±ndan en Ã§ok kullanÄ±lan ve bilinen NoSQL veritabanlarÄ±ndan birisidir. Redis, aÃ§Ä±k kaynaktÄ±r ve kaynak kodlarÄ±na GitHub Ã¼zerinden eriÅŸilebilmektedir. C dili ile yazÄ±ldÄ±ÄŸÄ± iÃ§in yÃ¼ksek performanslÄ± sonuÃ§lar vermektedir. Linux ve tÃ¼revi iÅŸletim sistemleri tarafÄ±ndan desteklenmekte fakat Windows tarafÄ± iÃ§in resmi bir destek olmasa da community tarafÄ±ndan desteklenmektedir.

Redis gÃ¼nÃ¼mÃ¼z sistemlerinde en Ã§ok kullanÄ±lan anahtar-deÄŸer veritabanÄ±dÄ±r ve genellikle caching, session yÃ¶netimi, pub/sub, message broker amacÄ±yla kullanÄ±lmaktadÄ±r

